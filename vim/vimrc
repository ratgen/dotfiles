" Install vim-plug if not found
if empty(glob('~/.config/nvim/autoload/plug.vim'))
    silent !curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs
                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
endif

" Run PlugInstall if there are missing plugins
autocmd VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
            \| PlugInstall --sync | source $MYVIMRC
            \| endif

call plug#begin('~/.config/nvim/plugged')
    "VimTeX extension for compiling tex documetns 
    Plug 'lervag/vimtex'                                  

    Plug 'junegunn/vim-easy-align'

    "Surrounding for quoting and parenthesizing
    Plug 'machakann/vim-sandwich'                         

    "Fuzzy search in files systemwide
    Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }   

    "Fuzzy search in files in vim
    Plug 'junegunn/fzf.vim' 

    "Git commands inside vim
    Plug 'tpope/vim-fugitive'                             

    "Display colors of codes inside .css and .html documents
    Plug 'ap/vim-css-color'                               

    "Bottom line displaying insert and file info
    Plug 'vim-airline/vim-airline'                          

    "Snippets
    Plug 'SirVer/ultisnips'                               

    "Library of snippets for ultisnips
    Plug 'honza/vim-snippets'                             

    "Theme
    Plug 'projekt0n/github-nvim-theme', { 'tag': 'v0.0.7' }

    "lsp configuration for nvim 
    Plug 'williamboman/mason.nvim'
    Plug 'williamboman/mason-lspconfig.nvim'
    Plug 'neovim/nvim-lspconfig'

    "Debug Adapter Protocol
    Plug 'mfussenegger/nvim-dap'
    Plug 'jayp0521/mason-nvim-dap.nvim'


    "Autocompletion plugin
    Plug 'hrsh7th/nvim-cmp'
    
    " sources for cmp-nvim
    Plug 'quangnguyen30192/cmp-nvim-ultisnips'
    Plug 'hrsh7th/cmp-nvim-lsp'
    Plug 'hrsh7th/cmp-path'
    Plug 'hrsh7th/cmp-calc'
    Plug 'hrsh7th/cmp-buffer'
    Plug 'hrsh7th/cmp-cmdline'
    Plug 'nvim-lua/plenary.nvim'
    Plug 'petertriho/cmp-git'


    Plug 'windwp/nvim-autopairs'


    "The bars for each indentation
    Plug 'Yggdroot/indentLine'

    "Expands the targets for 'change inner'
    Plug 'wellle/targets.vim'

    Plug 'yuezk/vim-js'
    Plug 'maxmellon/vim-jsx-pretty'

    "PlantUML Syntax
    Plug 'aklt/plantuml-syntax'
    Plug 'tyru/open-browser.vim'
    Plug 'weirongxu/plantuml-previewer.vim'

    "Autoclosing pairs

    Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
call plug#end()

xmap ga <Plug>(EasyAlign)

nmap ga <Plug>(EasyAlign)

nnoremap <C-t> :VimtexTocToggle<CR>      
let g:vimtex_toc_config = {
      \ 'show_help': 0
      \}


"----- Unmap the arrow keys in normal and visual mode
noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>
imap <Up> <Nop>
imap <Down> <Nop>
inoremap <Left> <Nop>
inoremap <Right> <Nop>

"----- Set the copying and pasting from the system clipboard 
nmap <leader>p "+gp
nmap <leader>y "+y

"---- Set the view of indentation and indentation to 2.
filetype indent on
set tabstop=2       "number of spaces a tab counts for
set shiftwidth=2    "number of space arrows count for 
set autoindent      "keep indentation when moving to a new line
set smartindent     "do indentation automatically 
set expandtab       "use spaces instead of tabs
set incsearch       "automatically show the first result of a pattern
set hlsearch        "highlight the results of a query.

autocmd filetype javascript set shiftwidth=2
autocmd filetype javascript set tabstop=2
autocmd filetype typesript set shiftwidth=2
autocmd filetype typesript set tabstop=2
autocmd filetype vue set shiftwidth=2
autocmd filetype vue set tabstop=2

"----- Interface options
set noshowmode      "Remove vim's own statusbar
set relativenumber  "make numbers relative to current position
set number          "Show numbers
set confirm         "display confirmation when closing unsaved file
set laststatus=2    "always show the statusbar (the one on the bottom)

"----- Set the color theme
set cursorline                          "Highlight the line on which the cursor is
set background=dark
colorscheme github_*

set mouse=

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#buffer_idx_mode = 1
let g:airline_powerline_fonts = 1

"----- Set aliases to improve efficiency
command W w                     
command Wq wq
command WQ wq
set completeopt=menu,menuone,noselect

function LectureStart(arg)
  execute '!mkdir -p lecture/' . a:arg
  echo "creating lecture/" . a:arg . '/lecture.tex'
  execute 'e lecture/' . a:arg. '/lecture.tex'
  execute 'normal 5o'
  call append(5,"% vim: spell spelllang=en")
  execute 'normal gg'
  execute 'w'
  execute 'e main.tex'
  execute '/lecture'
  execute 'normal N'
  execute 'normal o' . '\include{./lecture/' . a:arg . '/lecture.tex}'
  execute 'w'
  execute 'tabnew'
  execute 'e lecture/' . a:arg. '/lecture.tex'
endfunction

command -nargs=1 Lecture :call LectureStart(<f-args>)
"----- Set shortcuts in LaTeX documents
set tw=80          "set textwidth to 80
""autocmd filetype markdown set tw=80
""autocmd filetype text set tw=80

"----- set the placement of the swap files
set backupdir=~/.backup/,/tmp//
set directory=~/.swp/,/tmp//
set undodir=~/.undo/,/tmp//
set updatetime=300                  "Write the swapfile if nothings is written for 300 millisecs

"----- set vimtex options
let g:vimtex_fold_enabled=1
let g:vimtex_syntax_conceal_disable=1

"----- fzf search in file
"Search in buffer names
nnoremap <silent> <Leader>b :Buffers<CR>
"Search in files in directory
nnoremap <silent> <C-f> :Files<CR>
"Grep in files in the directory
nnoremap <silent> <Leader>f :Rg<CR>
"Search in current file
nnoremap <silent> <Leader>/ :BLines<CR>
"Search in marks
nnoremap <silent> <Leader>' :Marks<CR>
"Search in commits
nnoremap <silent> <Leader>c :Commits<CR>
nnoremap <silent> <Leader>H :Helptags<CR>
nnoremap <silent> <Leader>hh :History<CR>
nnoremap <silent> <Leader>h: :History:<CR>
nnoremap <silent> <Leader>h/ :History/<CR>
set grepprg=rg\ --vimgrep\ --smart-case\ --follow

"---- Abbreviations
"set spell                       "Enable spellchecking
"set spelllang=en_gb             "Set language for spellchecking
set modeline                    "Set options in each file

"-- Choose the first suggestion for mistake
inoremap <C-l> <c-g>u<Esc>[s1z=`]a<c-g>u

abbr SE Software Engineering
abbr hte the
abbr nad and

lua << EOF

require("nvim-autopairs").setup {}

require("github-theme").setup({
  theme_style = "dark",
  function_style = "italic",
  sidebars = {"qf", "vista_kind", "terminal", "packer"},

  -- Change the "hint" color to the "orange" color, and make the "error" color bright red
  colors = {hint = "orange", error = "#ff0000"},

  -- Overwrite the highlight groups
  overrides = function(c)
    return {
      htmlTag = {fg = c.red, bg = "#282c34", sp = c.hint, style = "underline"},
      DiagnosticHint = {link = "LspDiagnosticsDefaultHint"},
      -- this will remove the highlight groups
      TSField = {},
    }
  end
})


require("mason").setup()
require("mason-lspconfig").setup()

require("mason-lspconfig").setup_handlers {
  -- The first entry (without a key) will be the default handler
  -- and will be called for each installed server that doesn't have
  -- a dedicated handler.
  function (server_name) -- default handler (optional)
      require("lspconfig")[server_name].setup {}
  end,
  -- Next, you can provide a dedicated handler for specific servers.
  -- For example, a handler override for the `rust_analyzer`:
}
require("mason-nvim-dap").setup({
    automatic_setup = true,
})


require'nvim-treesitter.configs'.setup {
  -- A list of parser names, or "all"
  ensure_installed = { "c", "lua", "rust" },

  -- Install parsers synchronously (only applied to `ensure_installed`)
  sync_install = false,

  -- Automatically install missing parsers when entering buffer
  -- Recommendation: set to false if you don't have `tree-sitter` CLI installed locally
  auto_install = true,

  -- List of parsers to ignore installing (for "all")
  ignore_install = { "javascript" },

  ---- If you need to change the installation directory of the parsers (see -> Advanced Setup)
  -- parser_install_dir = "/some/path/to/store/parsers", -- Remember to run vim.opt.runtimepath:append("/some/path/to/store/parsers")!

  highlight = {
    -- `false` will disable the whole extension
    enable = true,

    disable = { "latex", "tex", "gitcommit"},
    additional_vim_regex_highlighting = false,
  },
}

local on_attach = function(client, bufnr)
local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

-- Mappings.
local opts = { noremap=true, silent=true }

-- See `:help vim.lsp.*` for documentation on any of the below functions
buf_set_keymap('n', 'gD', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
buf_set_keymap('n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)

end

local t = function(str)
  return vim.api.nvim_replace_termcodes(str, true, true, true)
end

vim.g.UltiSnipsExpandTrigger = '<Plug>(ultisnips_expand)'      
vim.g.UltiSnipsJumpForwardTrigger = '<Plug>(ultisnips_jump_forward)'
vim.g.UltiSnipsJumpBackwardTrigger = '<Plug>(ultisnips_jump_backward)'
vim.g.UltiSnipsListSnippets = '<c-x><c-s>'
vim.g.UltiSnipsRemoveSelectModeMappings = 0

require "cmp_buffer"
require "cmp_nvim_lsp"
require "cmp_calc"
require "cmp_path"
require "cmp_nvim_ultisnips"

WIDE_HEIGHT = 300

local cmp_autopairs = require('nvim-autopairs.completion.cmp')

local cmp = require'cmp'
cmp.setup({
  completion = {
    completeopt = 'menu,menuone,noselect',
    keyword_pattern = [[\%(-\?\d\+\%(\.\d\+\)\?\|\h\w*\%(-\w*\)*\)]],
    keyword_length = 1,
    get_trigger_characters = function(trigger_characters)
    return trigger_characters
  end,
  },
  snippet = {
      expand = function(args)
      vim.fn["UltiSnips#Anon"](args.body)
  end,
  },
  preselect = cmp.PreselectMode.Item,

  window = {
    completion = cmp.config.window.bordered(),
    documentation = cmp.config.window.bordered(),
  },
  confirmation = {
      default_behavior = cmp.ConfirmBehavior.Insert,
      get_commit_characters = function(commit_characters)
      return commit_characters
    end,
  },
  event = {},
  mapping = {
        ["<Tab>"] = cmp.mapping({
            c = function()
                if cmp.visible() then
                  cmp.select_next_item({ behavior = cmp.SelectBehavior.Insert })
                else
                    cmp.complete()
                end
            end,
            i = function(fallback)
                if cmp.visible() then
                    cmp.select_next_item({ behavior = cmp.SelectBehavior.Insert })
                elseif vim.fn["UltiSnips#CanJumpForwards"]() == 1 then
                    vim.api.nvim_feedkeys(t("<Plug>(ultisnips_jump_forward)"), 'm', true)
                else
                    fallback()
                end
            end,
            s = function(fallback)
                if vim.fn["UltiSnips#CanJumpForwards"]() == 1 then
                    vim.api.nvim_feedkeys(t("<Plug>(ultisnips_jump_forward)"), 'm', true)
                else
                    fallback()
                end
            end
        }),
        ["<S-Tab>"] = cmp.mapping({
            c = function()
                if cmp.visible() then
                    cmp.select_prev_item({ behavior = cmp.SelectBehavior.Insert })
                else
                    cmp.complete()
                end
            end,
            i = function(fallback)
                if cmp.visible() then
                    cmp.select_prev_item({ behavior = cmp.SelectBehavior.Insert })
                elseif vim.fn["UltiSnips#CanJumpBackwards"]() == 1 then
                    return vim.api.nvim_feedkeys( t("<Plug>(ultisnips_jump_backward)"), 'm', true)
                else
                    fallback()
                end
            end,
            s = function(fallback)
                if vim.fn["UltiSnips#CanJumpBackwards"]() == 1 then
                    return vim.api.nvim_feedkeys( t("<Plug>(ultisnips_jump_backward)"), 'm', true)
                else
                    fallback()
                end
            end
        }),
        ['<Down>'] = cmp.mapping(cmp.mapping.select_next_item({ behavior = cmp.SelectBehavior.Select }), {'i'}),
        ['<Up>'] = cmp.mapping(cmp.mapping.select_prev_item({ behavior = cmp.SelectBehavior.Select }), {'i'}),
        ['<C-n>'] = cmp.mapping({
            c = function()
                if cmp.visible() then
                    cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
                else
                    vim.api.nvim_feedkeys(t('<Down>'), 'n', true)
                end
            end,
            i = function(fallback)
                if cmp.visible() then
                    cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
                else
                    fallback()
                end
            end
        }),
        ['<C-p>'] = cmp.mapping({
            c = function()
                if cmp.visible() then
                    cmp.select_prev_item({ behavior = cmp.SelectBehavior.Select })
                else
                    vim.api.nvim_feedkeys(t('<Up>'), 'n', true)
                end
            end,
            i = function(fallback)
                if cmp.visible() then
                    cmp.select_prev_item({ behavior = cmp.SelectBehavior.Select })
                else
                    fallback()
                end
            end
        }),
        ['<C-b>'] = cmp.mapping(cmp.mapping.scroll_docs(-4), {'i', 'c'}),
        ['<C-f>'] = cmp.mapping(cmp.mapping.scroll_docs(4), {'i', 'c'}),
        ['<C-Space>'] = cmp.mapping(cmp.mapping.complete(), {'i', 'c'}),
        ['<C-e>'] = cmp.mapping({ i = cmp.mapping.close(), c = cmp.mapping.close() }),
        ['<CR>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.

  },
  formatting = {
      deprecated = true,
      format = function(_, vim_item)
      return vim_item
  end,
  },
  experimental = {
    ghost_text = false,
  },
  sources = {
      { name = "path" },
      { name = "ultisnips" },
      { name = "nvim_lsp" },
      -- { name = "buffer" },
      { name = "calc" },
    }
  }
)
window = {
  documentation = "native"
}

cmp.event:on(
  'confirm_done',
  cmp_autopairs.on_confirm_done()
)

-- Set configuration for specific filetype.
cmp.setup.filetype('gitcommit', {
  sources = cmp.config.sources(
    {
      { name = "ultisnips" },
    },
    {
      { name = 'git' }, -- You can specify the `cmp_git` source if you were installed it.
    }, 
    {
      { name = 'buffer' },
    }
    )
})

require("cmp_git").setup()



-- Use buffer source for `/` and `?` (if you enabled `native_menu`, this won't work anymore).
cmp.setup.cmdline({ '/', '?' }, {
  completion = { autocomplete = false },

  -- mapping = cmp.mapping.preset.cmdline(),
  sources = {
    { name = 'buffer' }
  }
})


cmp.setup.cmdline(':', {
 -- mapping = cmp.mapping.preset.cmdline(),
  completion = { autocomplete = false },
  sources = cmp.config.sources({
    { name = 'path' }
    }, {
      { name = 'cmdline', 
    }
  })
})


EOF

"vim set filetype=vim
